[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is the personal academic space of Daniel — researcher, educator, and author of R for Non-Programmers."
  },
  {
    "objectID": "blog/2025-06-30/multi-dimensional-gt-tables-r.html",
    "href": "blog/2025-06-30/multi-dimensional-gt-tables-r.html",
    "title": "Taming Multi-Dimensional Tables with gt",
    "section": "",
    "text": "Creating beautiful tables in R has never been easier thanks to the gt package. But what happens when your “simple” table suddenly needs three dimensions? That’s when things get interesting – and by interesting, I mean frustratingly complex.\nToday, we’ll walk through creating a multi-dimensional table that displays relationship status by gender across different countries. We’ll start simple and work our way up to the challenges that make you question your life choices (and then solve them, of course)."
  },
  {
    "objectID": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#meet-the-gt-package",
    "href": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#meet-the-gt-package",
    "title": "Taming Multi-Dimensional Tables with gt",
    "section": "Meet the GT Package",
    "text": "Meet the GT Package\nThe gt package by RStudio is a grammar of tables that makes creating publication-ready tables surprisingly enjoyable. Think of it as ggplot2 for tables – it’s structured, flexible, and produces gorgeous output with relatively little code.\nThe package follows a layered approach: you start with your data, create a basic gt() object, then add layers of formatting, styling, and functionality. Each function adds a specific element to your table, making the code readable and the process intuitive.\nIf you’re new to R or finding this tutorial challenging to follow, I’d recommend checking out R for Non-Programmers for a more gentle introduction to R fundamentals."
  },
  {
    "objectID": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#our-data-world-values-survey",
    "href": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#our-data-world-values-survey",
    "title": "Taming Multi-Dimensional Tables with gt",
    "section": "Our Data: World Values Survey",
    "text": "Our Data: World Values Survey\nWe’ll be working with data from the World Values Survey (WVS), which contains responses from people across different countries about their values and demographics. The wvs_nona dataset is a cleaned version where missing values have been removed (hence “nona” = no NAs).\nIf you want to follow along, you can get the dataset from the r4np package:\n\n# Install if you haven't already\n# install.packages(\"r4np\")\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(gt)\nlibrary(gtExtras)\nlibrary(r4np)\n\n# The dataset we'll use\nhead(wvs_nona)\n\n# A tibble: 6 × 6\n  country gender   age relationship_status freedom_of_choice satisfaction\n  &lt;fct&gt;   &lt;fct&gt;  &lt;dbl&gt; &lt;fct&gt;                           &lt;dbl&gt;        &lt;dbl&gt;\n1 Bolivia male      60 married                             7            5\n2 Bolivia male      40 married                             8            7\n3 Bolivia male      25 single                             10            8\n4 Bolivia female    71 widowed                             5            5\n5 Bolivia female    38 married                             5            7\n6 Bolivia female    20 separated                           5            3\n\n\nOur goal is to create a table showing the relationship between three variables: country, gender, and relationship_status. This is what makes it “multi-dimensional” – we’re not just showing a simple two-way relationship, but a three-way interaction."
  },
  {
    "objectID": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#step-1-the-innocent-beginning",
    "href": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#step-1-the-innocent-beginning",
    "title": "Taming Multi-Dimensional Tables with gt",
    "section": "Step 1: The Innocent Beginning",
    "text": "Step 1: The Innocent Beginning\nLet’s start with what seems like a straightforward task: create a table showing the count of married, separated, and divorced people by gender across countries.\nFirst, we need to count the combinations of our three variables:\n\n# Create our base data\ntable_data &lt;- wvs_nona %&gt;%\n  count(gender, country, relationship_status) %&gt;%\n  filter(relationship_status %in% c(\"married\", \"separated\", \"divorced\"))\n\n# Take a peek\nhead(table_data)\n\n# A tibble: 6 × 4\n  gender country relationship_status     n\n  &lt;fct&gt;  &lt;fct&gt;   &lt;fct&gt;               &lt;int&gt;\n1 female Bolivia married               383\n2 female Bolivia separated              62\n3 female Bolivia divorced               27\n4 female Iran    married               448\n5 female Iran    separated               4\n6 female Iran    divorced               24\n\n\nThe count() function is doing the heavy lifting here. It groups by the three variables we specify and counts how many observations fall into each combination. The filter() step narrows our focus to just three relationship statuses – we’re keeping the analysis manageable.\nThis gives us a “long” format dataset where each row represents one combination of country, gender, and relationship status, with the count in the n column.\nNow we need to reshape this data to make it suitable for a table. We want countries as rows and the gender-relationship combinations as columns:\n\n# Reshape for table format\nwide_data &lt;- table_data %&gt;%\n  pivot_wider(id_cols = country,\n              names_from = c(gender, relationship_status),\n              values_from = n)\n\nhead(wide_data)\n\n# A tibble: 6 × 7\n  country female_married female_separated female_divorced male_married\n  &lt;fct&gt;            &lt;int&gt;            &lt;int&gt;           &lt;int&gt;        &lt;int&gt;\n1 Bolivia            383               62              27          376\n2 Iran               448                4              24          518\n3 Iraq               442                6              10          423\n4 Japan              525                4              49          464\n5 Korea              491                1               1          407\n6 Egypt              399               10              23          434\n# ℹ 2 more variables: male_separated &lt;int&gt;, male_divorced &lt;int&gt;\n\n\npivot_wider() is the magic function here. Let’s break down what each argument does:\n\nid_cols = country: This tells R that country should remain as a column (our row identifier)\nnames_from = c(gender, relationship_status): These two variables will become column names\nvalues_from = n: The values that fill the table come from the n column (our counts)\n\nThe result is columns with names like female_married, male_divorced, etc. R automatically combines the values from gender and relationship_status with an underscore.\nNow let’s create our first GT table:\n\n# Our first attempt\nbasic_table &lt;- wide_data %&gt;%\n  gt() %&gt;%\n  tab_header(\n    title = \"World Value Survey (WVS)\",\n    subtitle = \"Relationship Status by Gender and Country\"\n  )\n\nbasic_table\n\n\n\n\n\n\n\nWorld Value Survey (WVS)\n\n\nRelationship Status by Gender and Country\n\n\ncountry\nfemale_married\nfemale_separated\nfemale_divorced\nmale_married\nmale_separated\nmale_divorced\n\n\n\n\nBolivia\n383\n62\n27\n376\n34\n24\n\n\nIran\n448\n4\n24\n518\n8\n6\n\n\nIraq\n442\n6\n10\n423\n5\n9\n\n\nJapan\n525\n4\n49\n464\n1\n20\n\n\nKorea\n491\n1\n1\n407\nNA\n7\n\n\nEgypt\n399\n10\n23\n434\n7\n9\n\n\n\n\n\n\n\nThe gt() function creates the basic table object, and tab_header() adds a title and subtitle. Simple enough, but not very pretty."
  },
  {
    "objectID": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#step-2-the-plot-thickens",
    "href": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#step-2-the-plot-thickens",
    "title": "Taming Multi-Dimensional Tables with gt",
    "section": "Step 2: The Plot Thickens",
    "text": "Step 2: The Plot Thickens\nOur basic table works, but it’s not exactly reader-friendly. Those column names like female_married are functional but ugly. We want to group them under gender headers with clean sub-labels.\n“No problem,” you think, “I’ll just use tab_spanner_delim()!”\n\n# Attempt with tab_spanner_delim()\nspanners_attempt &lt;- wide_data %&gt;%\n  gt() %&gt;%\n  tab_header(\n    title = \"World Value Survey (WVS)\",\n    subtitle = \"Relationship Status by Gender and Country\"  \n  ) %&gt;%\n  tab_spanner_delim(delim = \"_\")\n\nspanners_attempt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWorld Value Survey (WVS)\n\n\nRelationship Status by Gender and Country\n\n\ncountry\n\nfemale\n\n\nmale\n\n\n\nmarried\nseparated\ndivorced\nmarried\nseparated\ndivorced\n\n\n\n\nBolivia\n383\n62\n27\n376\n34\n24\n\n\nIran\n448\n4\n24\n518\n8\n6\n\n\nIraq\n442\n6\n10\n423\n5\n9\n\n\nJapan\n525\n4\n49\n464\n1\n20\n\n\nKorea\n491\n1\n1\n407\nNA\n7\n\n\nEgypt\n399\n10\n23\n434\n7\n9\n\n\n\n\n\n\n\ntab_spanner_delim() is GT’s convenient function for automatically creating column groups. It looks at your column names, splits them at the delimiter you specify (in this case, the underscore), and creates grouped headers.\nThis creates the gender groupings automatically by splitting on the underscore. The part before the underscore becomes the group header (“female”, “male”), and the part after becomes the column label (“married”, “separated”, “divorced”).\nIt’s clean, it’s automatic, and it… doesn’t let you customise the subcategory labels. You’re stuck with “married”, “separated”, “divorced” exactly as they appear in your column names.\nWhat if you want “Married” (capitalised), “Sep.” (abbreviated), or “Divorced/Separated” (combined)? What if you want to style them with bold or italic text? tab_spanner_delim() just shrugs and says “take it or leave it.”"
  },
  {
    "objectID": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#step-3-the-manual-labor-solution",
    "href": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#step-3-the-manual-labor-solution",
    "title": "Taming Multi-Dimensional Tables with gt",
    "section": "Step 3: The Manual Labor Solution",
    "text": "Step 3: The Manual Labor Solution\nThis is where GT shows both its power and its complexity. To get full control, we need to manually create our spanners and relabel our columns. It’s more work, but it’s infinitely more flexible.\nLet’s break this down step by step:\n\n# The manual approach - more control, more code\ncustom_table &lt;- wide_data %&gt;%\n  gt() %&gt;%\n  tab_header(\n    title = \"World Value Survey (WVS)\",\n    subtitle = \"Data extract from r4np\"\n  ) %&gt;%\n  \n  # Step 1: Create individual gender spanners\n  tab_spanner(\n    label = md(\"*female*\"),\n    columns = starts_with(\"female_\")\n  ) %&gt;%\n  tab_spanner(\n    label = md(\"*male*\"), \n    columns = starts_with(\"male_\")\n  ) %&gt;%\n  \n  # Step 2: Create an overarching gender spanner\n  tab_spanner(\n    label = md(\"**Gender**\"),\n    columns = starts_with(c(\"female_\", \"male_\")),\n    id = \"gender\"\n  ) %&gt;%\n  \n  # Step 3: Customise individual column labels\n  cols_label(\n    country = md(\"**Country**\"),\n    ends_with(\"married\") ~ \"Married\",\n    ends_with(\"separated\") ~ \"Separated\", \n    ends_with(\"divorced\") ~ \"Divorced\"\n  )\n\ncustom_table\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWorld Value Survey (WVS)\n\n\nData extract from r4np\n\n\n\n\nGender\n\n\n\nCountry\n\nfemale\n\n\nmale\n\n\n\nMarried\nSeparated\nDivorced\nMarried\nSeparated\nDivorced\n\n\n\n\nBolivia\n383\n62\n27\n376\n34\n24\n\n\nIran\n448\n4\n24\n518\n8\n6\n\n\nIraq\n442\n6\n10\n423\n5\n9\n\n\nJapan\n525\n4\n49\n464\n1\n20\n\n\nKorea\n491\n1\n1\n407\nNA\n7\n\n\nEgypt\n399\n10\n23\n434\n7\n9\n\n\n\n\n\n\n\nLet’s dissect what’s happening here:\nStep 1: Individual Gender Spanners\n\ntab_spanner(\n  label = md(\"*female*\"),\n  columns = starts_with(\"female_\")\n)\n\nThis creates a spanner (column group) labeled “female” that covers all columns starting with “female_”. The md() function allows us to use markdown formatting – in this case, italics with the asterisks.\nThe starts_with() function is a “tidy select” helper that selects columns based on their names. It’s much more reliable than typing out column names manually, especially when your column names follow a pattern.\nStep 2: Overarching Spanner\n\ntab_spanner(\n  label = md(\"**Gender**\"),\n  columns = starts_with(c(\"female_\", \"male_\")),\n  id = \"gender\"\n)\n\nThis creates a higher-level spanner that encompasses both gender groups. The columns argument uses a vector of prefixes to select all columns that start with either “female_” or “male_”. The id = \"gender\" gives this spanner a unique identifier that we could reference later if needed.\nStep 3: Column Label Customisation\n\ncols_label(\n  country = md(\"**Country**\"),\n  ends_with(\"married\") ~ \"Married\",\n  ends_with(\"separated\") ~ \"Separated\", \n  ends_with(\"divorced\") ~ \"Divorced\"\n)\n\nHere’s where the magic happens. cols_label() lets us rename columns, but it also supports conditional renaming using the ~ formula syntax.\n\ncountry = md(\"**Country**\"): Directly renames the country column\nends_with(\"married\") ~ \"Married\": This says “for any column that ends with ‘married’, rename it to ‘Married’”\n\nThis pattern-based renaming is incredibly powerful. Instead of writing:\n\n\n\nTable 1\n\n\nfemale_married = \"Married\",\nmale_married = \"Married\",\nfemale_separated = \"Separated\",\nmale_separated = \"Separated\"\n# ... and so on\n\n\n\nWe can use the formula syntax to apply the same transformation to multiple columns at once. The results is pretty respectable."
  },
  {
    "objectID": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#step-4-the-na-problem-plot-twist",
    "href": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#step-4-the-na-problem-plot-twist",
    "title": "Taming Multi-Dimensional Tables with gt",
    "section": "Step 4: The NA Problem (Plot Twist!)",
    "text": "Step 4: The NA Problem (Plot Twist!)\nBut wait, there’s more! Let’s add a total column to show the sum across relationship statuses:\n\n# Adding totals - first attempt\nwith_totals &lt;- wide_data %&gt;%\n  mutate(total = rowSums(select(., -country))) %&gt;%\n  gt() %&gt;%\n  # ... rest of our formatting code\n  cols_label(total = md(\"**Total**\"))\n\nwith_totals\n\nLet’s break down that mutate() line: - select(., -country): Selects all columns except country (the . refers to the current data frame) - rowSums(): Sums across columns for each row - mutate(total = ...): Creates a new column called total with these row sums\nYou might notice some countries have suspiciously low totals or NA values. That’s because rowSums() doesn’t handle NA values the way you might expect – if any value in a row is NA, the entire sum becomes NA.\nIn our case, NA in the count data doesn’t mean “missing information” – it means “zero observations for this combination.” For example, if a country has no divorced males in the survey, that cell will be NA, but for our table purposes, we want to treat it as zero."
  },
  {
    "objectID": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#step-5-the-na-solution",
    "href": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#step-5-the-na-solution",
    "title": "Taming Multi-Dimensional Tables with gt",
    "section": "Step 5: The NA Solution",
    "text": "Step 5: The NA Solution\nLet’s fix the NA problem properly:\n\n# The NA fix\nclean_data &lt;- wide_data %&gt;%\n  # Replace NA with 0 - this makes sense for count data\n  mutate(across(where(is.numeric), ~ if_else(is.na(.), 0, .))) %&gt;%\n  # Now rowSums will work properly\n  mutate(total = rowSums(select(., -country)))\n\nhead(clean_data)\n\nThis code introduces a powerful pattern:\nacross() for Multiple Column Operations\n\nmutate(across(where(is.numeric), ~ if_else(is.na(.), 0, .)))\n\nacross() is a function that applies the same transformation to multiple columns. Let’s break it down:\n\nwhere(is.numeric): Selects columns based on a condition – in this case, all numeric columns\n~ if_else(is.na(.), 0, .): This is a formula (notice the ~) that defines the transformation\n\nis.na(.): Checks if the value is NA (the . represents each value)\nif_else(condition, true_value, false_value): If the value is NA, replace with 0, otherwise keep the original value\n\n\nThis is much more efficient than writing separate mutate() statements for each column, and it’s robust – if you add more numeric columns later, they’ll automatically be included in the transformation."
  },
  {
    "objectID": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#step-6-the-full-solution-explained",
    "href": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#step-6-the-full-solution-explained",
    "title": "Taming Multi-Dimensional Tables with gt",
    "section": "Step 6: The Full Solution Explained",
    "text": "Step 6: The Full Solution Explained\nNow let’s put it all together with detailed explanations and a little bit of flair:\n\n# Our final, polished table\nfinal_table &lt;- wvs_nona %&gt;%\n  # Step 1: Create counts for each combination\n  count(gender, country, relationship_status) %&gt;%\n  \n  # Step 2: Filter to our relationship statuses of interest\n  filter(relationship_status %in% c(\"married\", \"separated\", \"divorced\")) %&gt;%\n  \n  # Step 3: Reshape from long to wide format\n  pivot_wider(id_cols = country,\n              names_from = c(gender, relationship_status),\n              values_from = n) %&gt;%\n  \n  # Step 4: Handle NAs properly for count data\n  mutate(across(where(is.numeric), ~ if_else(is.na(.), 0, .))) %&gt;%\n  \n  # Step 5: Add row totals\n  mutate(total = rowSums(select(., -country))) %&gt;%\n  \n  # Step 6: Create the GT table\n  gt() %&gt;%\n  \n  # Step 7: Add headers\n  tab_header(\n    title = \"World Value Survey (WVS)\",\n    subtitle = \"Data extract from r4np\"\n  ) %&gt;%\n  \n  # Step 8: Create nested column spanners\n  tab_spanner(\n    label = md(\"*female*\"),\n    columns = starts_with(\"female_\")\n  ) %&gt;%\n  tab_spanner(\n    label = md(\"*male*\"),\n    columns = starts_with(\"male_\")\n  ) %&gt;%\n  tab_spanner(\n    label = md(\"**Gender**\"),\n    columns = starts_with(c(\"female_\", \"male_\")),\n    id = \"gender\"\n  ) %&gt;%\n  \n  # Step 9: Customise column labels\n  cols_label(\n    country = md(\"**Country**\"),\n    total = md(\"**Total**\"),\n    ends_with(\"married\") ~ \"married\",\n    ends_with(\"separated\") ~ \"separated\",\n    ends_with(\"divorced\") ~ \"divorced\"\n  ) %&gt;%\n  \n  # Step 10: Add visual elements\n  gt_plt_bar(column = total) %&gt;%\n  \n  # Step 11: Add footer information\n  tab_footnote(md(\"**Source:**&lt;br&gt;*World Value Survey (2024)*\")) %&gt;%\n  \n  # Step 12: Apply a theme\n  gt_theme_espn()\n\nfinal_table\n\nAdmittedly, this code chunk is a lot more substantial than going with the standard gt table setup, but it certainly looks a lot more audience-ready and accessible\nLet me explain the final formatting steps so you can apply those changes to your own tables as well:\nVisual Enhancement with gt_plt_bar()\n\ngt_plt_bar(column = total)\n\nThis function from the gtExtras package adds mini bar charts to the total column. It automatically scales the bars based on the values in the column, making it easy to visually compare totals across countries. The bars appear within the table cells themselves.\nFootnotes for Attribution\n\ntab_footnote(md(\"**Source: **&lt;br&gt;*World Value Survey (2024)*\"))\n\ntab_footnote() adds a footnote to the table. The &lt;br&gt; is HTML for a line break, and again we’re using md() to enable markdown formatting for bold text and italics.\nTheming with gt_theme_espn()\n\ngt_theme_espn()\n\nThis applies a pre-built theme that mimics the ESPN sports network styling. The gtExtras package includes several pre-built themes that can dramatically change your table’s appearance with a single line of code. This is particularly helpful if you want to quickly apply a uniform style to all your tables in a presentation, report or publication."
  },
  {
    "objectID": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#why-this-approach-works",
    "href": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#why-this-approach-works",
    "title": "Taming Multi-Dimensional Tables with gt",
    "section": "Why This Approach Works",
    "text": "Why This Approach Works\nThe manual approach we’ve taken here solves several problems:\n\nFlexibility: We can style each spanner and column label exactly how we want.\nMaintainability: The pattern-based selection (starts_with(), ends_with()) means our code will work even if column names change slightly.\nScalability: If we add more countries or relationship statuses, most of the code will still work.\nReadability: Each step has a clear purpose and the code is self-documenting."
  },
  {
    "objectID": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#the-lessons-learned",
    "href": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#the-lessons-learned",
    "title": "Taming Multi-Dimensional Tables with gt",
    "section": "The Lessons Learned",
    "text": "The Lessons Learned\nCreating multi-dimensional tables in gt teaches us several important concepts:\n\nData shape matters: The structure of your data determines how easy it is to create your desired table. Sometimes reshaping is necessary.\nNA handling is context-dependent: In count data, NA often means zero, but in other contexts, it might mean something else entirely. Therefore, we might have to amend our table values as necessary.\nPattern-based selection is powerful: Functions like starts_with(), ends_with(), and where() make your code more robust, concise and less prone to errors.\nThe ~ formula syntax: This R feature appears in many places (cols_label(), across(), ggplot2) and is worth understanding deeply.\nLayered approach: gt’s philosophy of building tables layer by layer makes complex tables a lot more manageable.\n\nThe GT package is incredibly powerful, but like any sophisticated tool, it rewards understanding its patterns and conventions. When your table needs go beyond the basics, don’t be afraid to break down the problem into smaller steps and build up your solution incrementally."
  },
  {
    "objectID": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#want-to-learn-more",
    "href": "blog/2025-06-30/multi-dimensional-gt-tables-r.html#want-to-learn-more",
    "title": "Taming Multi-Dimensional Tables with gt",
    "section": "Want to Learn More?",
    "text": "Want to Learn More?\n\nGT Package Documentation - Comprehensive guide with examples\nGT Extras Package - Additional functionality and themes\nR for Non-Programmers - If you want to strengthen your R fundamentals\n\nThe key to mastering gt (and R in general) is understanding the building blocks and how they combine. Once you grasp these patterns, you’ll find yourself creating publication-ready tables with confidence and in no time.\nHappy table-making!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome to The Social Science Sofa.\nExplore posts, tutorials, and musings from the social science world.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTaming Multi-Dimensional Tables with gt\n\n\n\n\n\nLearn how to create multi-dimensional tables in R using the GT package. This step-by-step tutorial covers the challenges of nested column headers, handling NA values in count data, and moving beyond tab_spanner_delim() for full customisation control. Perfect for R users wanting to create publication-ready tables with complex structures.\n\n\n\n\n\nJun 30, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Taming Multi-Dimensional Tables with gt\n\n\n\n\n\nLearn how to create multi-dimensional tables in R using the GT package. This step-by-step tutorial covers the challenges of nested column headers, handling NA values in count data, and moving beyond tab_spanner_delim() for full customisation control. Perfect for R users wanting to create publication-ready tables with complex structures.\n\n\n\n\n\nJun 30, 2025\n\n\n\n\n\n\nNo matching items"
  }
]